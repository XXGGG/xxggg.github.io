(window.webpackJsonp=window.webpackJsonp||[]).push([[34],{533:function(t,a,s){"use strict";s.r(a);var e=s(4),r=Object(e.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"🥝什么是知识-🥝"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#🥝什么是知识-🥝"}},[t._v("#")]),t._v(" 🥝什么是知识?🥝")]),t._v(" "),s("p",[t._v("一些零零碎碎的知识点。"),s("br"),t._v("\n用自己简短的话概括。")]),t._v(" "),s("h2",{attrs:{id:"所谓冒泡-捕获"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#所谓冒泡-捕获"}},[t._v("#")]),t._v(" 所谓冒泡/捕获")]),t._v(" "),s("ul",[s("li",[t._v("冒泡 - （先触发里面， 再触发外边）像冒泡泡一样")]),t._v(" "),s("li",[t._v("捕获 - （从外到里）")])]),t._v(" "),s("blockquote",[s("p",[t._v("就是假设有两个div 一个在外边 一个在里面 都绑定了触发事件的按钮，当你的鼠标或者手指点击的时候会同时触发这两个按钮，那么这么来决定先触发哪个呢? （就是这么个问题）")])]),t._v(" "),s("h2",{attrs:{id:"所谓跨域"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#所谓跨域"}},[t._v("#")]),t._v(" 所谓跨域")]),t._v(" "),s("p",[t._v("跨域是指一个域下的文档或脚本试图去请求另一个域下的资源，这里跨域是广义的。")]),t._v(" "),s("h3",{attrs:{id:"什么是同源策略？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么是同源策略？"}},[t._v("#")]),t._v(" 什么是同源策略？")]),t._v(" "),s("p",[t._v('同源策略/SOP（Same origin policy）是一种约定，由Netscape公司1995年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。所谓同源是指"协议+域名+端口"三者相同，即便两个不同的域名指向同一个ip地址，也非同源。')]),t._v(" "),s("h2",{attrs:{id:"什么是递归"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么是递归"}},[t._v("#")]),t._v(" 什么是递归?")]),t._v(" "),s("p",[t._v("递归函数是在一个函数通过名字调用自身的情况下构成的")]),t._v(" "),s("h2",{attrs:{id:"什么是闭包"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么是闭包"}},[t._v("#")]),t._v(" 什么是闭包?")]),t._v(" "),s("blockquote",[s("p",[t._v("阮一峰"),s("a",{attrs:{href:"http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html"),s("OutboundLink")],1)])]),t._v(" "),s("p",[t._v("我的理解是，闭包就是能够读取其他函数内部变量的函数。")]),t._v(" "),s("p",[t._v('由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成"定义在一个函数内部的函数"。\n所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。')]),t._v(" "),s("blockquote",[s("p",[t._v("举个例子（我xxg自己的理解）")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[t._v("xxg(){\n    var xxggg;\n    axios.get(url).then((res)={\n        var xxg = res.data\n        xxggg = res.data\n    })\n\n    console.log(xxg)\n    console.log(xxggg) //外面得不到里面的\n    // 里面是一个封闭的包厢\n\n    //所以叫闭包\n}\n")])])]),s("h3",{attrs:{id:"闭包的用途"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#闭包的用途"}},[t._v("#")]),t._v(" 闭包的用途")]),t._v(" "),s("p",[t._v("闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。")]),t._v(" "),s("h3",{attrs:{id:"使用闭包的注意点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#使用闭包的注意点"}},[t._v("#")]),t._v(" 使用闭包的注意点")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。")])]),t._v(" "),s("li",[s("p",[t._v("闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。")])])]),t._v(" "),s("p",[t._v("匿名函数本身也是一个闭包")]),t._v(" "),s("p",[t._v("setter，可以在函数外部对函数内部的局部变量进行操作。")]),t._v(" "),s("h2",{attrs:{id:"this"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#this"}},[t._v("#")]),t._v(" this")]),t._v(" "),s("p",[t._v("this指的是函数运行时所在的环境\n经常要用")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[t._v("let that = this \n")])])]),s("p",[t._v("来先保存当前的环境 然后再进入内部环境去使用that来调用this")]),t._v(" "),s("h2",{attrs:{id:"什么是promise"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么是promise"}},[t._v("#")]),t._v(" 什么是Promise?")]),t._v(" "),s("p",[t._v("Promise : 翻译为 允诺"),s("br"),t._v("\nPromise是构造函数")]),t._v(" "),s("p",[t._v("Promise 对象用于表示一个异步操作的最终状态（完成或失败），以及该异步操作的结果值。")]),t._v(" "),s("h2",{attrs:{id:"aysnc-await-异步-等待"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#aysnc-await-异步-等待"}},[t._v("#")]),t._v(" aysnc/await 异步/等待")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[t._v('aysnc xxg(){\n    let res  = await xxx\n    console.log("先完成上面的")\n}\n')])])]),s("p",[t._v("当await的这个xxx是一个promise(英译:许诺，允诺)时, 那么awiat就会等待他完成以后再往下走!")]),t._v(" "),s("h2",{attrs:{id:"什么是回调函数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么是回调函数"}},[t._v("#")]),t._v(" 什么是回调函数?")]),t._v(" "),s("h2",{attrs:{id:"什么是持续集成"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么是持续集成"}},[t._v("#")]),t._v(" 什么是持续集成?")]),t._v(" "),s("h2",{attrs:{id:"什么是git-hook"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么是git-hook"}},[t._v("#")]),t._v(" 什么是git hook?")]),t._v(" "),s("blockquote",[s("p",[t._v("具体参考文章"),s("a",{attrs:{href:"https://www.cnblogs.com/jiaoshou/p/12222665.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://www.cnblogs.com/jiaoshou/p/12222665.html"),s("OutboundLink")],1),t._v("\ngit hook 其实就是钩子"),s("br"),t._v("\n特定事件发生之前或之后执行特定脚本代码功能（从概念上类比，就与监听事件、触发器之类的东西类似）"),s("br"),t._v("\nGit Hooks 就是那些在Git执行特定事件（如commit、push、receive等）后触发运行的脚本，挂钩是可以放置在挂钩目录中的程序，可在git执行的某些点触发动作。没有设置可执行位的钩子将被忽略。"),s("br"),t._v("\n默认情况下，hooks目录是$GIT_DIR/hooks，但是可以通过core.hooksPath配置变量来更改")])]),t._v(" "),s("h3",{attrs:{id:"有啥用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#有啥用"}},[t._v("#")]),t._v(" 有啥用")]),t._v(" "),s("p",[t._v("用处大得很，简单来说，规避风险和偷懒，我们不想把时间花在找一个语法错误的bug上面，也不想做一些重复性的操作，比如持续集成")]),t._v(" "),s("p",[t._v("现在大部分的持续集成的构建环境，比如travis和jekkins基本上和git hook的原理有关系")]),t._v(" "),s("p",[t._v("Git Hooks是定制化的脚本程序，所以它实现的功能与相应的git动作相关,如下几个简单例子：")]),t._v(" "),s("ol",[s("li",[t._v("多人开发代码语法、规范强制统一")]),t._v(" "),s("li",[t._v("commit message 格式化、是否符合某种规范")]),t._v(" "),s("li",[t._v("如果有需要，测试用例的检测")]),t._v(" "),s("li",[t._v("服务器代码有新的更新的时候通知所有开发成员")]),t._v(" "),s("li",[t._v("代码提交后的项目自动打包（git receive之后） 等等...")])]),t._v(" "),s("p",[t._v("更多的功能可以按照生产环境的需求写出来")]),t._v(" "),s("h2",{attrs:{id:"babel-是什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#babel-是什么"}},[t._v("#")]),t._v(" Babel 是什么?")]),t._v(" "),s("p",[t._v("Babel 是一个工具链，主要用于将 ECMAScript 2015+ 版本的代码转换为向后兼容的 JavaScript 语法，以便能够运行在当前和旧版本的浏览器或其他环境中。下面列出的是 Babel 能为你做的事情：")]),t._v(" "),s("ol",[s("li",[s("p",[t._v("语法转换")])]),t._v(" "),s("li",[s("p",[t._v("通过 Polyfill 方式在目标环境中添加缺失的特性 (通过 @babel/polyfill 模块)")])]),t._v(" "),s("li",[s("p",[t._v("源码转换 (codemods)")])])]),t._v(" "),s("p",[t._v("Babel是将ES6及以上版本的代码转换为ES5的工具。")]),t._v(" "),s("p",[t._v("它用 babel.config.js 或 .babelrc 文件作为配置文件，其中最为重要的配置参数是presets和plugins。")]),t._v(" "),s("p",[t._v("plugins：Babel插件可以将输入源码进行转换，输出编译后的代码。")]),t._v(" "),s("p",[t._v("presets：一组Babel插件，目的是方便使用。官方已经内置了一些preset，如babel-preset-env。")]),t._v(" "),s("p",[t._v("PS：其他的查看Babel文档就行。")]),t._v(" "),s("h2",{attrs:{id:"什么是-unit-testing-单元测试"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么是-unit-testing-单元测试"}},[t._v("#")]),t._v(" 什么是 Unit Testing 单元测试")]),t._v(" "),s("h2",{attrs:{id:"什么是-e2e-testing"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么是-e2e-testing"}},[t._v("#")]),t._v(" 什么是 E2E testing")]),t._v(" "),s("h2",{attrs:{id:"什么是css-预处理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么是css-预处理"}},[t._v("#")]),t._v(" 什么是Css 预处理")]),t._v(" "),s("h2",{attrs:{id:"什么是-pwa"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么是-pwa"}},[t._v("#")]),t._v(" 什么是 PWA")]),t._v(" "),s("h2",{attrs:{id:"什么是typescript"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么是typescript"}},[t._v("#")]),t._v(" 什么是TypeScript")])])}),[],!1,null,null,null);a.default=r.exports}}]);