(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{513:function(a,t,s){"use strict";s.r(t);var r=s(4),e=Object(r.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h1",{attrs:{id:"🥝什么是知识-🥝"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#🥝什么是知识-🥝"}},[a._v("#")]),a._v(" 🥝什么是知识?🥝")]),a._v(" "),s("p",[a._v("一些零零碎碎的知识点。")]),a._v(" "),s("h2",{attrs:{id:"所谓冒泡-捕获"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#所谓冒泡-捕获"}},[a._v("#")]),a._v(" 所谓冒泡/捕获")]),a._v(" "),s("ul",[s("li",[a._v("冒泡 - （先触发里面， 再触发外边）像冒泡泡一样")]),a._v(" "),s("li",[a._v("捕获 - （从外到里）")])]),a._v(" "),s("h2",{attrs:{id:"所谓跨域"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#所谓跨域"}},[a._v("#")]),a._v(" 所谓跨域")]),a._v(" "),s("p",[a._v("跨域是指一个域下的文档或脚本试图去请求另一个域下的资源，这里跨域是广义的。")]),a._v(" "),s("h3",{attrs:{id:"什么是同源策略？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么是同源策略？"}},[a._v("#")]),a._v(" 什么是同源策略？")]),a._v(" "),s("p",[a._v('同源策略/SOP（Same origin policy）是一种约定，由Netscape公司1995年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。所谓同源是指"协议+域名+端口"三者相同，即便两个不同的域名指向同一个ip地址，也非同源。')]),a._v(" "),s("h2",{attrs:{id:"什么是递归"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么是递归"}},[a._v("#")]),a._v(" 什么是递归?")]),a._v(" "),s("p",[a._v("递归函数是在一个函数通过名字调用自身的情况下构成的")]),a._v(" "),s("h2",{attrs:{id:"什么是闭包"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么是闭包"}},[a._v("#")]),a._v(" 什么是闭包?")]),a._v(" "),s("blockquote",[s("p",[a._v("阮一峰"),s("a",{attrs:{href:"http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html",target:"_blank",rel:"noopener noreferrer"}},[a._v("http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html"),s("OutboundLink")],1)])]),a._v(" "),s("p",[a._v("我的理解是，闭包就是能够读取其他函数内部变量的函数。")]),a._v(" "),s("p",[a._v('由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成"定义在一个函数内部的函数"。\n所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。')]),a._v(" "),s("blockquote",[s("p",[a._v("举个例子（我xxg自己的理解）")])]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v("xxg(){\n    var xxggg;\n    axios.get(url).then((res)={\n        var xxg = res.data\n        xxggg = res.data\n    })\n\n    console.log(xxg)\n    console.log(xxggg) //外面得不到里面的\n    // 里面是一个封闭的包厢\n\n    //所以叫闭包\n}\n")])])]),s("h3",{attrs:{id:"闭包的用途"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#闭包的用途"}},[a._v("#")]),a._v(" 闭包的用途")]),a._v(" "),s("p",[a._v("闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。")]),a._v(" "),s("h3",{attrs:{id:"使用闭包的注意点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#使用闭包的注意点"}},[a._v("#")]),a._v(" 使用闭包的注意点")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。")])]),a._v(" "),s("li",[s("p",[a._v("闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。")])])]),a._v(" "),s("p",[a._v("匿名函数本身也是一个闭包")]),a._v(" "),s("p",[a._v("setter，可以在函数外部对函数内部的局部变量进行操作。")]),a._v(" "),s("h2",{attrs:{id:"this"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#this"}},[a._v("#")]),a._v(" this")]),a._v(" "),s("p",[a._v("this指的是函数运行时所在的环境\n经常要用")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v("let that = this \n")])])]),s("p",[a._v("来先保存当前的环境 然后再进入内部环境去使用that来调用this")]),a._v(" "),s("h2",{attrs:{id:"什么是promise"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么是promise"}},[a._v("#")]),a._v(" 什么是Promise?")]),a._v(" "),s("p",[a._v("Promise : 翻译为 允诺"),s("br"),a._v("\nPromise是构造函数")]),a._v(" "),s("p",[a._v("Promise 对象用于表示一个异步操作的最终状态（完成或失败），以及该异步操作的结果值。")]),a._v(" "),s("h2",{attrs:{id:"aysnc-await-异步-等待"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#aysnc-await-异步-等待"}},[a._v("#")]),a._v(" aysnc/await 异步/等待")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v('aysnc xxg(){\n    let res  = await xxx\n    console.log("先完成上面的")\n}\n')])])]),s("p",[a._v("当await的这个xxx是一个promise(英译:许诺，允诺)时, 那么awiat就会等待他完成以后再往下走!")]),a._v(" "),s("h2",{attrs:{id:"什么是回调函数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么是回调函数"}},[a._v("#")]),a._v(" 什么是回调函数?")])])}),[],!1,null,null,null);t.default=e.exports}}]);